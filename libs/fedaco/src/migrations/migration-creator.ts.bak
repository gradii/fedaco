import { isBlank } from '@gradii/nanofn';
import { format } from 'date-fns';
import {dirname} from 'node:path'
import { existsSync, writeFileSync, mkdirSync, readdirSync } from 'node:fs';

export class MigrationCreator {
  /* The custom app stubs directory. */
  customStubPath: string;
  /* The registered post create hooks. */
  postCreate: any[] = [];

  /* Create a new migration creator instance. */
  public constructor(customStubPath: string) {
    this.customStubPath = customStubPath;
  }

  /* Create a new migration at the given path. */
  public create(name: string, path: string, table: string | null = null, create = false) {
    this.ensureMigrationDoesntAlreadyExist(name, path);
    const stub = this.getStub(table, create);
    path = this.getPath(name, path);
    const directory = dirname(path);
    if(!existsSync(directory)) {
      mkdirSync(directory, { recursive: true });
    }
    writeFileSync(path, this.populateStub(stub, table));
    this.firePostCreateHooks(table, path);
    return path;
  }

  /* Ensure that a migration with the given name doesn't already exist. */
  protected ensureMigrationDoesntAlreadyExist(name: string, migrationPath: string = null) {
    if (!isBlank(migrationPath)) {
      const files = readdirSync(migrationPath);
      const migrationFiles = []
      for(const file of files) {
        if(file.endsWith('.mjs') || file.endsWith('.js')) {
          migrationFiles.push(file);
        }
      }
    }
  }

  /* Get the migration stub file. */
  protected getStub(table: string | null, create: boolean) {
    let stub;
    if (isBlank(table)) {
      stub = this.files.exists(
        customPath = this.customStubPath + '/migration.stub') ? customPath : this.stubPath() + '/migration.stub';
    } else if (create) {
      stub = this.files.exists(
        customPath = this.customStubPath + '/migration.create.stub') ? customPath : this.stubPath() + '/migration.create.stub';
    } else {
      stub = this.files.exists(
        customPath = this.customStubPath + '/migration.update.stub') ? customPath : this.stubPath() + '/migration.update.stub';
    }
    return this.files.get(stub);
  }

  /* Populate the place-holders in the migration stub. */
  protected populateStub(stub: string, table: string | null) {
    if (!isBlank(table)) {
      var stub = str_replace(['DummyTable', '{{ table }}', '{{table}}'], table, stub);
    }
    return stub;
  }

  /* Get the full path to the migration. */
  protected getPath(name: string, path: string) {
    return path + '/' + this.getDatePrefix() + '_' + name + '.php';
  }

  /* Fire the registered post create hooks. */
  protected firePostCreateHooks(table: string | null, path: string) {
    for (const callback of this.postCreate) {
      callback(table, path);
    }
  }

  /* Register a post migration create hook. */
  public afterCreate(callback: Function) {
    this.postCreate.push(callback);
  }

  /* Get the date prefix for the migration. */
  protected getDatePrefix() {
    return format(new Date(), 'yyyy_MM_dd_HHmmss');
  }

  /* Get the path to the stubs. */
  public stubPath() {
    // const relativePath = fileURLToPath(import.meta.url)
    return __DIR__ + '/stubs';
  }

  /* Get the filesystem instance. */
  public getFilesystem() {
    return this.files;
  }
}
